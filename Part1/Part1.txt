# Include nios_macros.s to workaround a bug in the movia pseudo-instruction.
.include "nios_macros.s"

.equ JP1, 0x10000060
.equ DIR, 0x07f557ff

.global _start

_start:
	movia r8, JP1			# Copy address of JP1 into r8
	movia r9, DIR			# Store direction register values
	stwio r9, 4(r8)			# Initialise direction register
	movia r15, 0xfffffbff	# Activate only sensor0 
	stwio r15, 0(r8)		
	movia r7, 0xfffffbff
	movia r13, 0xfffbffff
	
	
check_sensor_0:
	#movia r15, 0xfffffbff			# Activate only sensor0 
	#stwio r15, 0(r8)		
	ldwio r18, 0(r8)
	and r18, r18, r7
	stwio r18, 0(r8) 
	
	ldwio r10, 0(r8)
	srli r10, r10, 11				# get the ready bit to the right
	andi r10, r10, 0x1				# extract the ready bit
	
	bne r10, r0, check_sensor_0		# if sensor is not ready yet, then repeat the above 2 steps
	
	ldwio r11, 0(r8)
	srli r11, r11, 27				# move 27 bits to the right
	andi r11, r11, 0x0F				# extract sensor values (bits 27..30)

	
check_sensor_5:
	#movia r15, 0xfffbffff			# Activate only sensor4 
	#stwio r15, 0(r8)		
	
	movia r16, 0xfffffff0
        ldwio r18, 0(r8)
	or r18, r18, r16
	and r18, r18, r13
	stwio r18, 0(r8) 
	ldwio r17, 0(r8)
	srli r17, r8, 19				# get the ready bit to the right
	andi r17, r17, 0x1				# extract the ready bit
	
	bne r17, r0, check_sensor_5		# if sensor is not ready yet, then repeat the above 2 steps
	
	ldwio r12, 0(r8)
	srli r12, r12, 27				# move 27 bits to the right
	andi r12, r12, 0x0F				# extract sensor values (bits 27..30)

#movia r9, 100000	

sensor_comparison:
	beq r11, r12, stop_motor
	bgt r11, r12, move_forward		# any imbalances should be resolved by moving motor in appropriate direction
	blt r11, r12, move_backward 
	
move_forward:
	movia r14, 0xfffffffc
	stwio r14, 0(r8)
	br check_sensor_0
	
move_backward:	
	movia r14, 0xfffffffe
	stwio r14, 0(r8)
	br check_sensor_0
	
stop_motor:
	movia r15, 0xfffffbff			# Activate only sensor0 
	stwio r15, 0(r8)
	br check_sensor_0
#count_loop:
	#subi r9, r9, 1
	#bne r9,r0,count_loop
	#br check_sensor_0
